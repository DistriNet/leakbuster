{
	"definitions": {
		"name": "string",
		"component": {
			"AP": "attacker page",
			"VW": "victim window",
			"VI": "victim iframe",
			"WS": "web server",
			"SO": "server-side OS",
			"BR": "browser",
			"CO": "client-side OS"
		},
		"inclusion_method": {
			"DS": "direct: specfic API",
			"DA": "direct: any API",
			"IF": "iframe",
			"WI": "other window"
		},
		"state_change_aspect": {
			"EV": "event fired",
			"PR": "change of a property",
			"CR": "consumption of limited resource"
		},
		"observation_method": {
			"OE": "observation of an event",
			"RP": "reading a property",
			"PP": "probing a property"
		},
		"affected_DOM_API": "string",
		"information_in_timing": "boolean",
		"intended_XS_information": "boolean",
		"idempotent": "boolean",
		"differentiating_aspect": {
			"MD": "metadata",
			"GP": "generation process",
			"CO": "content",
			"HE": "headers"
		},
		"references": "array[string]",
		"reference_urls": "array[string]",
		"reference_titles": "array[string]",
		"browsers": "array[string]",
		"description": "string",
		"show_on_site": "boolean"
	},
	"leaks": [
		{
			"name": "(in)valid script/image/...",
			"component": "AP",
			"inclusion_method": "DS",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "img/script/...",
			"information_in_timing": false,
			"intended_XS_information": true,
			"idempotent": true,
			"differentiating_aspect": ["CO", "HE"],
			"references": ["xsleakserrorevents", "staicu2019leaky"],
			"reference_urls": ["https://xsleaks.dev/docs/attacks/error-events/", "https://www.usenix.org/system/files/sec19fall_staicu_prepub.pdf"],
			"reference_titles": ["Error Events (XS-Leaks Wiki)", "Leaky Images: Targeted Privacy Attacks in the Web - Staicu et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "When including a resource as a script or an image, this will trigger an error event in case the content of the resource does not match the expected content. For instance, including an HTML resource in an `<img>` element will trigger an `error` event, whereas a valid image resource will result in a `load` event."
		},
		{
			"name": "response timing (size)",
			"component": "SO",
			"inclusion_method": "DA",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "",
			"information_in_timing": true,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "MD",
			"references": ["bortz2007exposing", "gelernter2015cross[\\S 3.1]"],
			"reference_urls": ["http://crypto.stanford.edu/~dabo/papers/webtiming.pdf", "https://446h.cybersec.fun/xssearch.pdf"],
			"reference_titles": ["Exposing Private Information by Timing Web Applications - Bortz et al. (PDF)", "Cross-Site Search Attacks - Gelernter et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "On the downstream connection between the server and the client, the time it takes the server to send the entire response to the client will depend on the size of the response. By measuring this time, an adversary can distinguish small and large responses."
		},
		{
			"name": "response timing (execution time)",
			"component": "WS",
			"inclusion_method": "DA",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "",
			"information_in_timing": true,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "GP",
			"references": ["gelernter2015cross[\\S 4]", "van2020timeless", "sanchez2019bakingtimer"],
			"reference_urls": ["https://446h.cybersec.fun/xssearch.pdf", "https://www.usenix.org/system/files/sec20-van_goethem.pdf", "https://www.eurecom.fr/publication/6118/download/sec-publi-6118.pdf"],
			"reference_titles": ["Cross-Site Search Attacks - Gelernter et al. (PDF)", "Timeless Timing Attacks: Exploiting Concurrency to Leak Secrets over Remote Connections - Van Goethem et al. (PDF)", "BakingTimer: Privacy Analysis of Server-Side Request Processing Time - Sanchez-Rola et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "The time it takes to generate a response might depend on the state of the user; for instance if the user is able to access a particular resource such as a private group on a social network site, the server might take additional steps to retrieve these, resulting in a timing difference. The computation time can be observed with a typical cross-site timing or a timeless timing attack. An attacker could try to inflate the measured timing difference to reduce the measurement noise introduced by jitter."
		},
		{
			"name": "frame counting",
			"component": ["VI", "VW"],
			"inclusion_method": ["IF", "WI"],
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "frames.length",
			"information_in_timing": false,
			"intended_XS_information": true,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["xsleaksframecounting"],
			"reference_urls": ["https://xsleaks.dev/docs/attacks/frame-counting/"],
			"reference_titles": ["Frame Counting (XS-Leaks Wiki)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "When the attacker has a reference to a window in which the target resource was loaded, they can retrieve the number of frames that are loaded in this document by accessing the `frames.length` property. It is also possible to determine the number of frames in the entire frame-tree, for instance by checking `frames[0].length` for the number of iframes embedded in the first frame."
		},
		{
			"name": "client redirect (History API)",
			"component": "VW",
			"inclusion_method": "WI",
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "History API",
			"information_in_timing": false,
			"intended_XS_information": true,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["xsleaksnavigations"],
			"reference_urls": ["https://xsleaks.dev/docs/attacks/navigations/"],
			"reference_titles": ["Navigations (XS-Leaks Wiki)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "The History API keeps track of which navigations occurred, which is accessible through the `History.length` property. An adversary can navigate a separate window to the target resource and wait for it to finish loading, and subsequently navigate that window to an attacker-controlled web page. By accessing the `history.length` property, the attacker will be able to infer how many client-side redirects or calls to the `history.pushState()` API were made by the target resource. Note that server-side redirects using the `Location` header are not counted."
		},
		{
			"name": "client redirect (load event)",
			"component": "AP",
			"inclusion_method": "IF",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "iframe.onload",
			"information_in_timing": false,
			"intended_XS_information": true,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["xsleaksnavigations"],
			"reference_urls": ["https://xsleaks.dev/docs/attacks/navigations/"],
			"reference_titles": ["Navigations (XS-Leaks Wiki)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "When a document resource is included as an iframe, the `load` event will be fired every time a document is loaded. Therefore, when a client-side redirect occurs after the document has loaded, the `load` event will be fired multiple times."
		},
		{
			"name": "appearance of download bar",
			"component": "BR",
			"inclusion_method": "WI",
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "window.height",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": false,
			"differentiating_aspect": "HE",
			"references": ["xsleaksnavigations"],
			"reference_urls": ["https://xsleaks.com/docs/attacks/navigations/#download-bar"],
			"reference_titles": ["Navigations - download bar (XS-Leaks Wiki)"],
			"browsers": ["chrome"],
			"show_on_site": true,
			"description": "When a resource that is opened in a new window is served with the `Content-Disposition: attachment` header, it will be downloaded by the browser. In Chromium-based browsers, this will cause the download bar to appear, causing the height of the window to be reduced. This download bar will remain there until it is closed by the user."
		},
		{
			"name": "no navigation due to download",
			"component": ["VI", "VW"],
			"inclusion_method": ["IF", "WI"],
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["xsleaksnavigations"],
			"reference_urls": ["https://xsleaks.com/docs/attacks/navigations/#download-navigation-with-iframes"],
			"reference_titles": ["Navigations - download navigation (with iframes) (XS-Leaks Wiki)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "If a resource with the `Content-Disposition` header set to `attachment` is loaded in an iframe or window, this will cause the resource to be downloaded and no navigation will occur in the iframe or window. As a result, the document's origin remains `about:blank`. In this case, the attacker can still access SOP-protected attributes, such as `window.origin`."
		},
		{
			"name": "server redirect (max redirect count)",
			"component": "AP",
			"inclusion_method": "DA",
			"state_change_aspect": "CR",
			"observation_method": "OE",
			"affected_DOM_API": "Fetch",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["maxredirects", "maxredirectsportswig"],
			"reference_urls": ["https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1267"],
			"reference_titles": ["XSLeaks in redirect flows - presentation by Luan Herrera"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "According to the Fetch specification, when twenty server-side redirects occur, a network error will be returned. As such, to determine whether a specific resource causes a redirect, the attacker can first make a request to their own server and redirect 19 times, after which a redirect to the target resource occurs. If this resource redirects, a network error can be observed, otherwise the resource will be loaded. Note that this method can also be used to determine the exact number of redirects that occur."
		},
		{
			"name": "server redirect (CSP violation)",
			"component": "AP",
			"inclusion_method": "DA",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "CSP",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["xsleaksnavigations"],
			"reference_urls": ["https://xsleaks.com/docs/attacks/navigations/#csp-violations"],
			"reference_titles": ["Navigations - CSP violations (XS-Leaks Wiki)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "By defining a (restrictive) Content Security Policy on their page, the attacker can determine from which hosts resources are allowed to be loaded. In case a resource from a different host is loaded, this will result in a violation of the CSP, which can be observed by listening for a `securitypolicyviolation` event. As such, this allows an attacker do determine whether a resource redirects to a host that is not defined in the allowed sources according to the attacker's defined CSP policy."
		},
		{
			"name": "server redirect/status (AppCache)",
			"component": "AP",
			"inclusion_method": "DA",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "AppCache",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["lee2015identifying", "maxredirects"],
			"reference_urls": ["https://sangho2.github.io/papers/lee:appcache.pdf", "https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1166"],
			"reference_titles": ["Identifying Cross-origin Resource Status Using Application Cache", "XSLeaks in redirect flows - presentation by Luan Herrera"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "Entries in the AppCache manifest that redirect or have a non-200 status code will cause an `error` event on the `applicationCache` object; in case no redirect occurs, the `cached` event will be fired. This allows an attacker to determine whether a certain resource will cause a redirect."
		},
		{
			"name": "server redirect (Fetch manual)",
			"component": "AP",
			"inclusion_method": "DS",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "Fetch",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["maxredirects"],
			"reference_urls": ["https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234"],
			"reference_titles": ["XSLeaks in redirect flows - presentation by Luan Herrera"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "When the `redirect` option of in the `fetch()` call is set to `manual`, the returned `Promise` will resolve in case a redirect happens, otherwise the promise will be rejected. The attacker can determine whether a redirect occurred by interpreting the resolution of the promise."
		},
		{
			"name": "cache probing",
			"component": ["BR"],
			"inclusion_method": ["IF", "WI"],
			"state_change_aspect": "PR",
			"observation_method": "PP",
			"affected_DOM_API": "HTTP cache",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": false,
			"idempotent_note": "idempotent_techniques_available",
			"differentiating_aspect": "CO",
			"references": ["xsleakcacheprobing", "felten2000timing"],
			"reference_urls": ["https://xsleaks.dev/docs/attacks/cache-probing/", "http://www.cs.jhu.edu/~fabian/courses/CS600.424/course_papers/webtiming.pdf"],
			"reference_titles": ["Cache Probing (XS-Leaks Wiki)", "Timing Attacks on Web Privacy - Felten et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": false,
			"description": "When a resource is added to the HTTP cache, it will be loaded much faster in comparison to retrieving the resource over the network. When a specific document resource is loaded in an iframe or window, this may cause specific (other) resources to be added to the cache. The attacker can then use a timing attack to determine if any resource was cached. Cached resources will remain in the cache until they are invalidated, hence making this technique non-idempotent. Nevertheless, there exist various techniques that allow an adversary to remove specific entries from the cache."
		},
		{
			"name": "element id focus",
			"component": "AP",
			"inclusion_method": "IF",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "window.onblur",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["xsleaksidattribute"],
			"reference_urls": ["https://xsleaks.dev/docs/attacks/id-attribute/"],
			"reference_titles": ["ID Attribute (XS-Leaks Wiki)"],
			"browsers": ["chrome", "safari"],
			"show_on_site": true,
			"description": "When a document resource is loaded in an iframe where the URL fragment is set to the ID of a DOM element on the page, the browser will focus this iframe, causing the embedding (attacker) page to lose focus, which can be observed by listening for the `blur` event."
		},
		{
			"name": "Loophole (event loop timing)",
			"component": "BR",
			"inclusion_method": ["IF", "WI"],
			"state_change_aspect": "CR",
			"observation_method": "PP",
			"affected_DOM_API": "",
			"information_in_timing": true,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["vila2017loophole"],
			"reference_urls": ["https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-vila.pdf"],
			"reference_titles": ["Loophole: Timing Attacks on Shared Event Loops in Chrome - Vila et al. (PDF)"],
			"browsers": ["chrome"],
			"show_on_site": true,
			"description": "Browsers make use of event loops to handle the different events that happen. When an event loop is shared by different cross-site pages (in particular the attacker page and its target page), the attacker page can leak the time that the other page requires to handle events by continuously triggering events and observing the delay between them (a larger delay indicates that an event had to be handled for the other page)."
		},
		{
			"name": "overly broad postMessage",
			"component": "AP",
			"inclusion_method": ["IF", "WI"],
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "postMessage",
			"information_in_timing": false,
			"intended_XS_information": true,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["xsleakpostmessage"],
			"reference_urls": ["https://xsleaks.dev/docs/attacks/postmessage-broadcasts/"],
			"reference_titles": ["postMessage Broadcasts (XS-Leaks Wiki)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "To allow for cross-site communication, the postMessage API can be used. For instance, an embedded page can send a message to the top-most page by using `top.postMessage(msg, origin)`. The second argument of this function defines the origin for which the message is intended. If this is set to the wildcard `*`, the message will be sent regardless of the origin of the attacker."
		},
		{
			"name": "detect CORB'ed JSON responses",
			"component": "AP",
			"inclusion_method": "DS",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "CORB",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": ["HE", "CO"],
			"references": ["lukaszcorb"],
			"reference_urls": ["https://docs.google.com/document/d/1kdqstoT1uH5JafGmRXrtKE4yVfjUVmXitjcvJ4tbBvM/edit"],
			"reference_titles": ["CORB vs side channels - Łukasz Anforowicz (Chromium)"],
			"browsers": ["chrome"],
			"show_on_site": true,
			"description": "When a valid JSON document is included as in `<script>` element, it will cause a `SyntaxError`, which can be observed by listening to the `error` event. However, if the response is blocked by CORB, the body will be emptied, and no syntax error will occur."
		},
		{
			"name": "detect CORP header",
			"component": "AP",
			"inclusion_method": "DA",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "CORP",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["xsleakcorpleaks"],
			"reference_urls": ["https://xsleaks.dev/docs/attacks/browser-features/corp/"],
			"reference_titles": ["CORP Leaks (XS-Leaks Wiki)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "Similar to the CORB'ed responses, if a CORP header is present and it is not set to `cross-origin`, it will be blocked, which can then be observed in the attacker page. Alternatively, to detect it when it is set to `cross-origin`, the attacker can set the COEP header on their page to `require-corp`, which will prevent the resource from loading if the CORP header is not present."
		},
		{
			"name": "detect COOP header",
			"component": "AP",
			"inclusion_method": "WI",
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "COOP",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["xsleaks_coop"],
			"reference_urls": ["https://xsleaks.dev/docs/defenses/opt-in/coop/"],
			"reference_titles": ["Cross-Origin-Opener-Policy (XS-Leaks Wiki)"],
			"browsers": ["chrome", "firefox"],
			"show_on_site": false,
			"description": "When a page sets the COOP header, it will prevent other pages from retaining a reference to it. Hence, to check whether the COOP header is set, the attacker could open the resource in a new window, and then verify whether the reference to this window is still available."
		},
		{
			"name": "detect XFO (<object>)",
			"component": "AP",
			"inclusion_method": "DS",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "XFO",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["sudhodanan2019cross"],
			"reference_urls": ["https://arxiv.org/pdf/1908.02204.pdf"],
			"reference_titles": ["Cross-Origin State Inference (COSI) Attacks: Leaking Web Site States through XS-Leaks - Sudhodanan et al. (PDF)"],
			"browsers": ["firefox"],
			"show_on_site": true,
			"description": "When a document resource is included in an `<object>` element, and it sets the `X-Frame-Options` header to `DENY`, no `load` event will be fired on the object element. Without the XFO header, the event will be fired."
		},
		{
			"name": "detect XFO (Resource Timing)",
			"component": "AP",
			"inclusion_method": "DA",
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "Resource Timing API",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["xsleakxfo"],
			"reference_urls": ["https://xsleaks.github.io/xsleaks/examples/x-frame/index.html"],
			"reference_titles": ["X-Frame-Options and Status Type Detector - (XS-Leaks Wiki)"],
			"browsers": ["chrome"],
			"show_on_site": true,
			"description": "Typically, when a resource is loaded, a new `PerformanceResourceTiming` entry is created. However, in Chromium-based browsers, this does not happen when an XFO-enabled document resource is loaded in an iframe." 
		},
		{
			"name": "Safari ITP leaks",
			"component": "BR",
			"inclusion_method": "WI",
			"state_change_aspect": "PR",
			"observation_method": "PP",
			"affected_DOM_API": "Intelligent Tracking Prevention",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": false,
			"differentiating_aspect": "CO",
			"references": ["janc2020information"],
			"reference_urls": ["https://storage.googleapis.com/pub-tools-public-publication-data/pdf/7450c395e2d3ca583b24f0b8fbf704aa3c781692.pdf"],
			"reference_titles": ["Information Leaks via Safari’s Intelligent Tracking Prevention - Janc et al."],
			"browsers": ["safari"],
			"show_on_site": false,
			"description": "The Intelligent Tracking Prevention mechanism in Safari browsers maintains a list of domains to which several cross-site requests are made. Whenever a cross-site request is made to a particular site, that domain is given a strike, and after sufficient strikes from a sufficient amount of top-level sites, the domain will be added to the ITP list. When cross-site requests to domains on the ITP list are made, the `Referer` header and any cookies will be stripped. To perform an XS-Leak attack, the attacker can trigger the loading of the target document resource, and afterwards use various side-channels to infer whether this caused any particular domain to be added to the ITP list. Because the ITP list is only cleared when the browsing history is cleared, the attack is non-idempotent. Note that this issue has been mitigated in Safari."
		},
		{
			"name": "response size estimate (parsing)",
			"component": "AP",
			"inclusion_method": "DS",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "audio/video",
			"information_in_timing": true,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "MD",
			"references": ["van2015clock"],
			"reference_urls": ["https://tom.vg/papers/timing-attacks_ccs2015.pdf"],
			"reference_titles": ["The Clock is Still Ticking: Timing Attacks in the Modern Web - Van Goethem et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "The time it takes to parse a resource as an audio or video element depends on the size of the resource. Hence, by measuring the time (repeatedly), an estimation of the response size can be made."
		},
		{
			"name": "response size estimate (Cache API)",
			"component": "AP",
			"inclusion_method": "DS",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "Cache API",
			"information_in_timing": true,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "MD",
			"references": ["van2015clock"],
			"reference_urls": ["https://tom.vg/papers/timing-attacks_ccs2015.pdf"],
			"reference_titles": ["The Clock is Still Ticking: Timing Attacks in the Modern Web - Van Goethem et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "The time it takes to add or remove a response to the cache (using the Cache API), depends on its size. By repeated measurements, an estimate of this size can be obtained."
		},
		{
			"name": "response size (Quota API)",
			"component": "AP",
			"inclusion_method": "DS",
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "Quota API",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "MD",
			"references": ["van2016request[\\S 3.4.1]", "kim2016inferring"],
			"reference_urls": ["https://tom.vg/papers/request_and_conquer_usenix2016.pdf", "https://sangho2.github.io/papers/kim:quota.pdf"],
			"reference_titles": ["Request and Conquer: Exposing Cross-Origin Resource Size - Van Goethem et al. (PDF)", "Inferring Browser Activity and Status Through Remote Monitoring of Storage Usage - Kim et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "To prevent abuse, the available quota that each website is provided with, is limited. The available quota can be retrieved from by calling the following API: `navigator.storage.estimate()`. A website can observe the currently allotted quota, force the target resource to be cached (using the Cache API), and observe the quota again. The size of the resource will be the difference between the two values."
		},
		{
			"name": "response size (global quota eviction)",
			"component": "AP",
			"inclusion_method": "DS",
			"state_change_aspect": "CR",
			"observation_method": "PP",
			"affected_DOM_API": "Storage API",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "MD",
			"references": ["van2016request[\\S 3.4.2]"],
			"reference_urls": ["https://tom.vg/papers/request_and_conquer_usenix2016.pdf"],
			"reference_titles": ["Request and Conquer: Exposing Cross-Origin Resource Size - Van Goethem et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "Next to a per-site quota, there also exists a global storage quota. When this limit is reached, the least-recently used site will be evicted. If an attacker can force one of their sites to be evicted (of which they know the size), they can retrieve the size of the response by adding the target resource to the cache and then fill up the remainder of the global quota byte by byte, until another eviction occurs."
		},
		{
			"name": "detecting connections (pool limit)",
			"component": "BR",
			"inclusion_method": ["IF", "WI"],
			"state_change_aspect": "CR",
			"observation_method": "PP",
			"affected_DOM_API": "",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["chromiumbugsconnectionpool"],
			"reference_urls": ["https://bugs.chromium.org/p/chromium/issues/detail?id=843157"],
			"reference_titles": ["Chromium issue 843157: Security: leak cross-window request timing by exhausting connection pool"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "The global number of concurrent connections is limited, and when it is reached, the least-recently used connection will be terminated. An attacker can thus determine how many new connections the rendering of the target document resource caused by first establishing the maximum number of concurrent connections to their server, and then detecting how many of those were closed by the user."
		},
		{
			"name": "window.name leak",
			"component": ["VI", "VW"],
			"inclusion_method": ["IF", "WI"],
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "window.name",
			"information_in_timing": false,
			"intended_XS_information": true,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["htmlspeciframename"],
			"reference_urls": ["https://html.spec.whatwg.org/multipage/iframe-embed-object.html#attr-iframe-name"],
			"reference_titles": ["WHATWG HTML specification - iframe name attribute"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "By setting the `window.name` property, a name is given to the current browsing context. When the document within this browsing context is navigated to a different page, this name is retained, and thus becomes available across origins."
		},
		{
			"name": "Cross-Site Script Inclusion (XSSI)",
			"component": "WS",
			"inclusion_method": "DS",
			"state_change_aspect": "PR",
			"observation_method": "RP",
			"affected_DOM_API": "",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["lekies2015unexpected"],
			"reference_urls": ["https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-lekies.pdf"],
			"reference_titles": ["The Unexpected Dangers of Dynamic JavaScript - Lekies et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "Some websites may dynamically generate JavaScript that contains potentially sensitive user information. An attacker can embed this JavaScript in their page, and then read out the sensitive data, either by accessing a global property, overwriting a prototype, or redefining global APIs."
		},
		{
			"name": "CPU cache attacks",
			"component": "CO",
			"inclusion_method": ["IF", "WI"],
			"state_change_aspect": "PR",
			"observation_method": "PP",
			"affected_DOM_API": "",
			"information_in_timing": true,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["oren2015spy", "shusterman2019robust", "shusterman2021prime"],
			"reference_urls": ["https://www.cs.columbia.edu/~simha/spyjs.ccs15.pdf", "https://www.usenix.org/system/files/sec19fall_shusterman_prepub.pdf", "https://www.usenix.org/system/files/sec21fall-shusterman.pdf"],
			"reference_titles": ["The Spy in the Sandbox: Practical Cache Attacks in JavaScript and their Implications - Oren et al. (PDF)", "Robust Website Fingerprinting Through the Cache Occupancy Channel - Shusterman et al. (PDF)", "Prime+Probe 1, JavaScript 0: Overcoming Browser-based Side-Channel Defenses - Shusterman et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "When a document resource is rendered in the browser, this typically results in various executions on the CPU, which in turn results in various changes at the microarchitectural level. Prior work has (repeatedly) shown that the trace of changes made to the last-level cache can identify which websites are being visited, i.e., in a website fingerprinting attack. As this technique allows distinguishing two different execution traces of rendering a document resource, it could in theory also be leveraged to launch XS-Leak attacks."
		},
		{
			"name": "cross-site pixel stealing",
			"component": "AP",
			"inclusion_method": "IF",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "",
			"information_in_timing": true,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "CO",
			"references": ["andrysco2015subnormal", "kohlbrenner2017effectiveness"],
			"reference_urls": ["https://www.ieee-security.org/TC/SP2015/papers-archived/6949a623.pdf", "https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-kohlbrenner.pdf"],
			"reference_titles": ["On Subnormal Floating Point and Abnormal Timing - Andrysco et al. (PDF)", "On the effectiveness of mitigations against floating-point timing channels - Kohlbrenner et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "When a page embeds a document resource in a frame, it can perform certain manipulation on what is visually displayed. For instance, SVG filters and CSS rules can be applied. In case the execution of applying these filters on untrusted data, i.e., the pixels of a cross-site page, is not performed in constant-time, the timing information can be abused to extract text and other visuals from the targeted page."
		},
		{
			"name": "response status (AppCache)",
			"component": "AP",
			"inclusion_method": "DA",
			"state_change_aspect": "EV",
			"observation_method": "OE",
			"affected_DOM_API": "AppCache",
			"information_in_timing": false,
			"intended_XS_information": false,
			"idempotent": true,
			"differentiating_aspect": "HE",
			"references": ["lee2015identifying"],
			"reference_urls": ["https://sangho2.github.io/papers/lee:appcache.pdf"],
			"reference_titles": ["Identifying Cross-origin Resource Status Using Application Cache - Lee et al. (PDF)"],
			"browsers": ["chrome", "firefox", "safari"],
			"show_on_site": true,
			"description": "If a resource is cached using the Application Cache mechanism, it will result in an error depending on the response status. More precisely, when there is a non-200 response code returned for the to-be-cached resource, an observable error will be thrown, thereby leaking this information to the attacker."
		}
	],
	"notes": {
		"idempotent_techniques_available": {
			"icon": "$\\dagger$",
			"text": "Although the default technique is non-idempotent, there exists at least one technique that enables idempotent execution of this XS-Leak."
		}
	}
}